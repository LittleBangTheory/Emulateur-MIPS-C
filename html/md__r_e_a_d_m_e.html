<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPS: Projet CS351 (2022-2023): Émulateur MIPS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MIPS<span id="projectnumber">&#160;Final version</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Projet CS351 (2022-2023): Émulateur MIPS </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<p> title: Projet CS351 (2022-2023): Émulateur MIPS author: Robin Lafage, Gabin Chognot </p>
<h1><a class="anchor" id="autotoc_md3"></a>
date: 18/10/2022</h1>
<h1><a class="anchor" id="autotoc_md4"></a>
Rendu 1</h1>
<ul>
<li>Cochez (en remplaçant <code>[ ]</code> par <code>[x]</code>) si vous avez :<ul>
<li>[x] Vérifié que <code>make test-cli</code> ne renvoie pas d'erreur.</li>
<li>[x] Vérifié que <code>make tests</code> se plaint sur le nombre d'instructions et pas sur l'existence des fichiers de sortie.</li>
<li>[x] Vu que les soumissions se font avec <code>make tar</code>.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
Rendu 2</h1>
<p >(Une dizaine de lignes devrait suffire à chaque fois)</p>
<ul>
<li>Comment avez-vous choisi de programmer l'analyse de texte (dont la lecture des opérandes entières) ?</li>
</ul>
<p >Nous avons fait le choix de lire le fichier d'entrée ligne par ligne, puis d'écrire des fonctions qui permettent de récupérer les informations contenues dans l'instrucion c'est à dire le type de l'instruction, l'opcode, et les opérandes entières. Pour le type, nous avons implémenté 3 tableaux, chacun contenant la liste des instructions du même type, puis après lecture du premier mot de la ligne (c'est à dire l'instruction), nous parcourons chaque tableau pour déterminer son type. Pour l'opcode, nous avons fait un disjonction de cas pour toutes les instructions possibles car il n'y a pas de modèle général. Enfin, pour les opérandes entières, nous avons fait le choix d'implémenter 3 fonctions : une récupère les opérandes d'une instruction de type I, une pour le type J et une pour le type R. Les trois fonctionnent de la manière suivante : -L'instruction et l'opérande voulu (rd, rs, rt, ...) sont passés en paramètre -Selon l'opérande voulu, on parcourt la chaine de caractère jusqu'au premier, deuxieme, ou troisieme $, puis on renvoie sous forme d'entier la valeur de l'opérande. Dans le cas ou l'opérande n'est pas précédée d'un $, on renvoie la valeur située apres un espace, une fois que tous les $ ont été parcours.</p>
<ul>
<li>Avez-vous vu des motifs récurrents émerger ? Avez-vous "factorisé" ces motifs pour éviter de les répéter ? Si non, serait-ce difficile ?</li>
</ul>
<p >Les instructions sont encodées de la même manière selon le type, nous avons donc "factorisé" l'encodage en binaire de l'instruction selon son type, sauf pour le type R où nous avons dû différencier quelques cas qui sortaient du modèle général. C'est le cas notamment des instructions type R qui ne prennent que 1 ou 2 arguments au lieu de 3 par exemple. Idem pour la lecture des opérandes entières qui se fait pareillement suivant le type, sauf pour le type R qui admet quelques différences de la même manière que pour l'encodage. Sans cette "factorisation", il aurait été long et fastidieux de traiter les instructions au cas par cas, et difficilement maintenable si on veux ajouter une instruction au jeu d'instructions.</p>
<ul>
<li>Comment avez-vous procédé pour écrire les tests ? Étes-vous confiant·e·s que toutes les instructions gérées sont couvertes ?</li>
</ul>
<p >Nous avons rédigé deux autre fichiers sur le modèle du fichier test arithmetics.s déjà fourni avec le sujet, un fichier logic.s qui contient toutes les instructions logiques, et un fichier system.s qui contient toutes les instructions de type jump et de rotation/shift de mots. Nous avons supposé que les fichiers commençaient à 0x0000 pour utiliser les instructions de type jump. Nous avons été attentifs à ce que ces trois fichiers tests contiennent ensemble la totalité du jeu d'instruction MIPS, et certaines instructions se retrouvent même testées plusieurs fois. D'une part pour assurer la cohérence des instructions entre elles (pouvoir déterminer les EXPECTED_FINAL_STATE) pour la suite du projet), et également pour assurer que toutes les configurations d'usage étaient prises en compte.</p>
<ul>
<li>Quelle a été votre expérience avec l'utilisation et la compréhension de la documentation (ie. des annexes) ?</li>
</ul>
<p >Notre expérience a été dans l'ensemble positive avec la documentation, celle-ci étant claire et complète. Pour chacune des instruction, la manière dont elle est encodée est indiquée avec précision, ce qui nous a permis d'y voir clair quant à l'écriture de nos fonctions.</p>
<ul>
<li>Cochez (en remplaçant <code>[ ]</code> par <code>[x]</code>) si vous avez :<ul>
<li>[x] Implémenté la traduction pour des instructions de toutes les catéories (calcul, comparaisons, sauts, HI/LO, mémoire)</li>
<li>[x] Implémenté la traduction pour toutes les instructions de l'annexe 2</li>
<li>[x] Pris en compte les cas particuliers : valeurs négatives, hors limites, noms d'instructions ou opérandes invalides...</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Rendu 3</h1>
<p >(10/15 lignes devrait suffire à chaque fois)</p>
<ul>
<li>Quelle structure en modules planifiez-vous d'utiliser pour l'émulateur ?</li>
</ul>
<p >Nous avons découpé nos modules en 7 parties :</p>
<p >Les modules de mode : -Le module pas-à-pas, qui permet de lire un fichier ligne par ligne et de demander validation de l'utilisateur pour passer à la ligne suivante -Le module automatique, qui permet de lire un fichier ligne par ligne sans demander d'input utilisateur -Le module interactif, qui permet de lire les instructions une par une entrées par l'utilisateur dans la console</p>
<p >Les modules de fonctionnalité : -Le module de lecture et de conversion des instructions, qui permet de nettoyer les instructions, de les convertir en binaire puis en hexadécimal, et de les encoder. -Le module de récupération des mnémotechniques, des opérandes et des types, qui permet de récupérer le code de l'opération puis le type de l'instruction par disjonction de cas, et les opérandes de l'instruction selon le type. -Le module d'execution des instructions, qui permet de récupérer la commande et les opérandes en appelant les fonctions du module de lecture et conversion, et d'executer les instructions selon leur commande et leurs arguments, en mettant à jour les registres. Nous avons choisit de ne pas séparer les instructions par type à l'execution car les instructions de même type ne prennent pas forcément le même nombre d'arguments ni ne s'executent de la même manière. -Le module de mémoire, qui permet de simuler la mémoire à l'aide de listes chainées, qui va contenir les données via l'instruction SW et les récupérer via l'instruction LW.</p>
<ul>
<li>Quelles seront les fonctions principales de chaque module ?</li>
</ul>
<p >Les modules de mode : -Le module pas-à-pas, qui contient seulement <code>pas_a_pas</code>, qui permet de lire un fichier ligne par ligne en encodant les instructions en hexadécimal et en les éxécutant, puis de demander validation de l'utilisateur pour passer à la ligne suivante.</p>
<p >-Le module automatique, qui contient seulement <code>automatique</code>, qui permet de lire un fichier ligne par ligne en encodant les instructions en hexadécimal et en les éxécutant.</p>
<p >-Le module interactif, qui contient seulement <code>interactif</code>, qui permet de lire les instructions une par une entrées par l'utilisateur dans la console, de les encoder en hexadécimal et de les éxécuter.</p>
<p >-Le module de lecture et de conversion des instructions contient notamment : <code>clean_instruction</code> qui permet de supprimer à la fin des instructions les espaces, les tabulations et les retours à la ligne. <code>convert_hexa</code> qui permet de convertir une instruction binaire en hexadécimal. <code>convert_binaire</code> qui permet de convertir une instruction décimale en binaire. <code>encoder</code> qui permet de concaténer les éléments de l'instruction convertis en binaire et de convertir l'ensemble en hexadécimal en appelant convert_hexa. -Le module de récupération des mnémotechniques, des opérandes et des types contient notamment : <code>getType</code> qui permet de récupérer le type de l'instruction. <code>getOpCode</code> qui permet de récupérer le code opération de l'instruction (le mnémotechnique). <code>getIArgs</code>, <code>getJArgs</code>, et <code>getRArgs</code> qui permettent de récupérer les opérandes de l'instruction. -Le module d'execution des instructions, qui contient notamment : <code>get_args</code> qui permet de récupérer la commande et les opérandes de l'instruction en appelant les fonctions du module de lecture et de conversion. <code>execute</code> qui permet d'executer l'instruction selon la commande et les opérandes récupérées.</p>
<ul>
<li>Quels avantages voyez vous à cette structure (à comparer à un unique fichier)?</li>
</ul>
<p >L'organisation en module permet de séparer les différentes fonctionnalités de l'émulateur, et donc de les développer et de les tester séparément. Cela permet également de mieux comprendre le fonctionnement de l'émulateur, et de le modifier plus facilement au besoin.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Rendu 4</h1>
<ul>
<li>Avez-vous réussi à suivre la structure prévue au rendu 3 ? Quelles modifications ont été nécessaires ? Rétrospectivement, est-ce que cette structure était bien prévue ?</li>
</ul>
<p >Nous avons du implémenter une liste chainée pour stocker les instructions, nous n'en n'avions pas eu besoin au rendu 3. La structure des fonctions correspondait bien à la manière dont nous nous sommes finalement organisés.</p>
<ul>
<li>Avez-vous compris le fonctionnement de chaque instruction à partir de la documentation fournie ? Si non, quels sont les points obscurs ?</li>
</ul>
<p >La documentation était parfois un peu floue sur certaines instructions, mais nous avons pu comprendre le fonctionnement de chaque instruction avec un peu d'aide.</p>
<ul>
<li>Quels exemples de programmes avez-vous choisi pour tester le calcul ? Les comparaisons et sauts ? La mémoire ?</li>
</ul>
<p >Nous avons utilisé nos propres fichiers tests, ainsi que ceux fournis par le sujet, et au cours des différents rendus.</p>
<ul>
<li>Le sujet spécifie-t-il tous les détails nécessaires pour bien implémenter la mémoire ? Quels choix avec-vous faits ?</li>
</ul>
<p >Nous avons fait le choix d'implémenter une liste chaînée, mais il aurait probablement été possible de le faire avec un tableau, en sacrifiant une part de flexibilité.</p>
<ul>
<li>Reste-t-il des bugs que vous avez découverts et pas corrigés ?</li>
</ul>
<p >L'instruction MULT n'est probablement pas bien implémentée, il semble que pour les résultats qui occupent plus de 32 bits, il y ait des décalages. Les overflow provoquent des comportement innatendus dans le code, ils modifient des sorties qui ne devraient pas l'être.</p>
<ul>
<li>D'autres remarques sur votre programme ?</li>
</ul>
<p >Nous avons trouvé certaines consignes peu claires au lancement du projet, et nous nous lancions pour la première fois dans un projet de cette envergure. A cause de ces deux éléments, nous jugeons avoir fourni un programme fonctionnel, mais qui aurait mérité d'être plus optimisé et mieux organisé dans son architecture.</p>
<ul>
<li>Cochez (en remplaçant <code>[ ]</code> par <code>[x]</code>) si vous avez :**<ul>
<li>[x] Implémenté l'émulation de toutes les instructions gérées par le rendu 2.</li>
<li>[x] Implémenté l'émulation de toutes les instructions.</li>
<li>[x] Tous vos tests qui passent.</li>
<li>[x] Vérifié que vous tests couvrent toutes les instructions émulées.</li>
<li>[x] Testé les cas particuliers : valeurs négatives, overflows...</li>
<li>[x] Testé les cas d'erreur : division par zéro, sauts invalides...</li>
<li>[x] Un port fonctionnel de DOOM pour votre émulateur.</li>
</ul>
</li>
<li>Des retours sur le projet en général ?</li>
</ul>
<p >C'est le projet de C le plus poussé que nous avons eu à mener jusqu'à présent. Il nous a permis de comprendre mieux le fonctionnement du langage C et de ses outils, ainsi que de nous faciliter la compréhension du RISCV pour notre examen. Nous n'avons plus de mal à utiliser les fichiers, les listes chaînées, etc. Et nous avons aussi appris grâce à ce projet le fonctionnement de GDB, Valgrind, et Doxygen. Vous trouverez d'ailleurs une documentation Doxygen dans le dossier racine. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
